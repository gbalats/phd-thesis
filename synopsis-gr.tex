% Συνοπτική περιγραφή του διδακτορικού (5--8 σελίδες).

% (αυτήν|την|δεν|μην) [βδγφθχμνλρσζ]
% (αυτή|τη|δε|μη) (μπ|ντ|γκ|κ|π|τ|ξ|ψ)

% Η διατριβή αυτή αφορά τον ευρύτερο τομέα της στατικής ανάλυσης
% προγραμμάτων, η οποία αποσκοπεί στην αυτόματη κατανόηση του
% προγράμματος με βάση την εξέταση του πηγαίου του κώδικα, αλλά δίχως να
% προϋποθέτει την εκτέλεσή του. Στο τεράστιο εύρος τεχνικών και
% μεθοδολογιών στατικής ανάλυσης προγραμμάτων, όταν ο στόχος είναι μία
% συνολική εικόνα του προγράμματος, είναι συνήθης πρακτική η κατασκευή
% ενός αφηρημένου μοντέλου της μνήμης, το οποίο καλύπτει όλες τις
% πιθανές εκτελέσεις. Το μοντέλο αυτό αποτελείται από αφηρημένα
% αντικείμενα που αντιστοιχούν σε δεσμεύσεις μνήμης, κατά την
% αντικειμενοστρεφή ορολογία, κι εκφράζει χρήσιμες ιδιότητες και σχέσεις
% μεταξύ των αντικειμένων. Ωστόσο, σε κάποιες περιπτώσεις οι
% καθιερωμένες μέθοδοι για την κατασκευή αυτών των μοντέλων αποτυγχάνουν
% να αποτυπώσουν βασική δομική πληροφορία για τα αντικείμενα αυτά με
% αποτέλεσμα τον εκφυλισμό της πληροφορίας που παράγουν.

Σκοπός της συγκεκριμένης διατριβής είναι η διερεύνηση μεθόδων
βελτίωσης της ποιότητας της πληροφορίας στατικών αναλύσεων, μέσω της
ανάκτησης πληροφορίας περί της δομής των αντικειμένων που
δημιουργούνται στη μνήμη.  Οι ισχυρότερες εκ των στατικών αναλύσεων
για αντικειμενοστραφείς γλώσσες προγραμματισμού χρειάζεται να
κατασκευάσουν ένα αφηρημένο μοντέλο της μνήμης, όπου εικονικά
αντικείμενα αναπαριστούν (μία ή περισσότερες) διακριτές δεσμεύσεις
αντικειμένων.  Έτσι, μπορούν να υπολογίσουν μία εκτίμηση της
συμπεριφοράς του προγράμματος με σκοπό είτε τη μηχανικά υποβοηθούμενη
κατανόηση, είτε την εύρεση σφαλμάτων, ή τη βελτιστοποίηση της
απόδοσης του προγράμματος.  Η γνώση της δομής των αντικειμένων αυτών,
η οποία συνήθως συνοψίζεται στον τύπο του αντικειμένου, δύναται να
χαθεί μερικώς
\begin{inparaenum}[(1)]
\item λόγω χρήσης συγκεκριμένων προγραμματιστικών ιδιωμάτων,
\item όταν η γλώσσα είναι αρκετά χαμηλού επιπέδου (π.χ., {\en C/C++})
  δίνοντας άμεση πρόσβαση στη μνήμη (π.χ., μέσω αριθμητικής δεικτών),
\item κατά την ανάλυση μερικών προγραμμάτων (δηλαδή, προγραμμάτων για
  τα οποία δεν διαθέτουμε ολόκληρο τον κώδικα), ή
\item κατά τη χρήση μηχανισμών ανάκλασης ({\en reflection}).
\end{inparaenum}

Οι τεχνικές που προτείνονται είναι οι εξής:
\begin{itemize}
\item Για προγράμματα {\en C/C++} (ως τυπικού παραδείγματος γλώσσας με
  άμεση πρόσβαση στη μνήμη):

  Προτείνουμε την επέκταση του αφηρημένου μοντέλου μνήμης, ώστε αυτό
  να διέπεται από μεγαλύτερη διακριτότητα των αντικειμένων που
  δημιουργεί, αναδεικνύοντας βασικά στοιχεία της εσωτερικής τους
  δομής.  Συγκεκριμένα, αυτό περιλαμβάνει τη δημιουργία διακριτών
  αντικειμένων που αναπαριστούν πεδία, θέσεις πινάκων, καθώς και
  πολλαπλούς τύπους του ίδιου αντικειμένου, και το κατάλληλο χειρισμό
  τους ώστε να προσθέσουν στην ακρίβεια της ανάλυσης.  Όσον αφορά τους
  τύπους κάθε αντικειμένου, αυτοί ανιχνεύονται δυναμικά κατά την
  διάρκεια της ανάλυσης, παρακολουθώντας την κανονική ροή των αρχικών
  αντικειμένων εφόσον αυτά έχουν άγνωστο τύπο.  Οι δυναμικές αυτές
  τεχνικές καταλήγουν σε έναν αμοιβαία αναδρομικό υπολογισμό, όμοιο με
  αυτό της δυναμικής κατασκευής του γράφου κλήσεων ({\en call-graph}).
  Με την επέκταση αυτή του μοντέλου της μνήμης, η ανάλυση μπορεί να
  διατηρήσει πλήρη ακρίβεια κατά την εικονική κλήση μεθόδων σε
  αντικειμενοστρεφή κώδικα, ακόμα κι αν αυτές έχουν μεταφραστεί σε
  πολλαπλές χαμηλού επιπέδου εντολές, το οποίο είναι αναμενόμενο στην
  περίπτωση μίας χαμηλού επιπέδου γλώσσας όπως η {\en C/C++}.
\item Για προγράμματα {\en Java} (ως τυπικού παραδείγματος γλώσσας
  υψηλότερου επιπέδου):

  Η βασική απώλεια δομικής πληροφορίας στην περίπτωση της {\en Java},
  ως υψηλού επιπέδου γλώσσα που δεν παρέχει απευθείας πρόσβαση στην
  μνήμη, είναι η ανάλυση μερικών προγραμμάτων, δηλαδή προγραμμάτων τα
  οποία έχουν αναφορές σε κλάσεις/μεθόδους οι οποίες λείπουν από το
  πρόγραμμα προς ανάλυση.  Σε αυτή την περίπτωση, μπορούμε να
  ανακτήσουμε τουλάχιστον κάποια πληροφορία τύπου και σχέσεων
  κληρονομικότητας των κλάσεων που απουσιάζουν, καθώς και ένα ελάχιστο
  υποσύνολο των μελών τους, με βάση τη χρήση τους στο υπάρχον μέρος
  του προγράμματος.  Έτσι, μπορεί να κατασκευαστεί ένα πλήρες
  πρόγραμμα που να πληρεί τις εγγυήσεις ορθότητας του {\en Java
    Verifier}.  Η βασική δυσκολία σε αυτή την κατασκευή έγκειται στην
  συμπλήρωση της ιεραρχίας των κλάσεων.  Οι υπάρχουσες σχέσεις
  υποτυπισμού θα πρέπει να συμπληρωθούν έτσι ώστε να σχηματίσουμε μία
  πλήρη ιεραρχία που να μην εισάγει κυκλικές εξαρτήσεις και να
  ικανοποιεί λοιπούς περιορισμούς (π.χ., μία κλάση στη {\en Java}
  μπορεί να κληρονομήσει μόνο μία κλάση, ενώ δεν ισχύει το ίδιο για
  ένα {\en interface}).  Το πρόβλημα αυτό ανάγεται σε θεμελιώδη
  αλγοριθμικά προβλήματα θεωρίας γράφων με πιθανώς ευρύτερο
  ενδιαφέρον.  Παρουσιάζονται αλγόριθμοι προς επίλυση αυτών των
  προβλημάτων.

  Μία δεύτερη περίπτωση απώλειας δομικής πληροφορίας προγραμμάτων {\en
    Java} είναι η χρήση του μηχανισμού ανάκλασης ({\en reflection}), ο
  οποίος δίνει τη δυνατότητα σε ένα πρόγραμμα να παρατηρεί δυναμικά τη
  δομή των κλάσεων και των αντικειμένων στη μνήμη κι επιτρέπει ακόμα
  και την τροποποίησή τους, χωρίς να προϋποθέτει κάποια στατική γνώση
  των τύπων ή της γενικότερης μορφής τους.  Παρότι κώδικας που
  χρησιμοποιεί ανάκλαση μπορεί να είναι εντελώς αγνωστικός ως προς τα
  αντικείμενα που χειρίζεται, μία στατική ανάλυση θα πρέπει να
  εκτιμήσει σωστά τη μορφή τους ώστε να είναι σε θέση να προσεγγίσει
  τη δυναμική συμπεριφορά του προγράμματος.  Προτείνονται μία σειρά
  τεχνικών για τη δυναμική ανίχνευση των τύπων και της δομής αυτών των
  αντικειμένων.
\end{itemize}
 
Το περιεχόμενο της διατριβής αποτελείται από επτά κεφάλαια.  Το πρώτο
κεφάλαιο περιέχει μία σύντομη εισαγωγή περί του αφηρημένου μοντέλου
μνήμης των στατικών αναλύσεων και των περιπτώσεων όπου χάνεται βασική
δομική πληροφορία των αντικειμένων.  Επίσης, παρουσιάζεται η
ερευνητική αλλά και η πρακτική συνεισφορά της διατριβής.


% ------------------------------------------------------------------------------
% Structure-sensitive Analysis for C/C++ part
% ------------------------------------------------------------------------------


Το δεύτερο κεφάλαιο μελετά τις τεχνικές ανάκτησης δομικής πληροφορίας
σε χαμηλού επιπέδου γλώσσες με άμεση πρόσβαση στη μνήμη, όπως η {\en
  C/C++}.
%
Τα βασικά χαρακτηριστικά της {\en C/C++} που προκαλούν απώλεια δομικής
πληροφορίας είναι:
\begin{itemize}[--]
\item η δυνατότητα αποθήκευσης της διεύθυνσης μνήμης ενός πεδίου (ή
  θέσης πίνακα) κάποιου αντικειμένου
\item οι χαμηλού επιπέδου ρουτίνες δέσμευσης μνήμης (π.χ., {\en
    \code{malloc()}}) που αγνοούν τους τύπους των αντικειμένων που
  κατασκευάζουν
\item τα εμφωλευμένα αντικείμενα.
\end{itemize}
%
Παρουσιάζεται ένα ανανεωμένο αφηρημένο μοντέλο, με βασικό
χαρακτηριστικό τη μεγαλύτερη διακριτότητα των αντικειμένων που
κατασκευάζει, το οποίο επιτρέπει την ανεμπόδιστη καταγραφή των τύπων
σε αρκετές περιπτώσεις όπου κάτι τέτοιο δεν θα ήταν δυνατόν με τις
καθιερωμένες τεχνικές.  Για να εξασφαλίσουμε κάτι τέτοιο, βασιζόμαστε
σε δυναμικές τεχνικές διασύνδεσης αντικειμένων με υπάρχοντες τύπους,
των οποίων η ισχύς έγκειται στο ότι δρουν ταυτόχρονα ως καταναλωτές
αλλά και παρασκευαστές της πληροφορίας περιεχομένων των δεικτών που
υπολογίζει η βασική ανάλυση. Παρουσιάζουμε επίσης επεκτάσεις της
ανάλυσης για
\begin{inparaenum}[(1)]
\item αριθμητική δεικτών,
\item αναγνώριση ταυτοτικών διευθύνσεων μνήμης,
\item δομική συμβατότητα τύπων και
\item χειρισμό λειτουργιών αντιγραφής μνήμης.
\end{inparaenum}
Χρησιμοποιούμε κανόνες συμπερασμού για να παρουσιάσουμε το σύνολο των
τεχνικών μας.

Παρέχουμε το εργαλείο {\en \cclyzer{}} για στατική ανάλυση
προγραμμάτων {\en LLVM bitcode} (μία ενδιάμεση γλώσσα για {\en C/C++}
που χρησιμοποιείται από τον μεταγλωττιστή {\en clang}), το οποίο
περιλαμβάνει υλοποιήσεις των τεχνικών μας στη γλώσσα {\en Datalog}.
%
Για την αξιολόγηση του συνόλου των τεχνικών που παρουσιάστηκαν,
συγκρίνουμε με μία από τις πιο διαδεδομένες αναλύσεις για {\en C/C++}
με δυνατότητα διάκρισης πεδίων
\cite{paste/PearceKH04,toplas/PearceKH07} και δείχνουμε πως οι
τεχνικές μας αυξάνουν σημαντικά την ακρίβεια της ανάλυσης.


% ------------------------------------------------------------------------------
% Java Reflection Handling part
% ------------------------------------------------------------------------------

Το τρίτο κεφάλαιο μελετά τις τεχνικές ανάκτησης δομικής πληροφορίας σε
πρόγραμματα {\en Java}, τα οποία κάνουν χρήση του μηχανισμού ανάκλασης
({\en reflection}).  Ο μηχανισμός αυτός επιτρέπει σε προγράμματα {\en
  Java} να προσομοιώσουν τη συμπεριφορά δυναμικών γλωσσών κι
επιτρέπουν τη συγγραφή πλήρως πολυμορφικού κώδικα που δεν χρειάζεται
να γνωρίζει τίποτα για τους στατικούς τύπους του προγράμματος. Η
απουσία των στατικών τύπων, ωστόσο, θέτει αρκετές δυσκολίες στη
στατική ανάλυση του προγράμματος. Ένα παράδειγμα χρήσης ανάκλασης
είναι το παρακάτω:
{\en
  \begin{javacodelinum}
    String className = ... ;
    Class c = Class.forName(className);
    Object o = c.newInstance();
    String methodName = ... ;
    Method m = c.getMethod(methodName, ...);
    m.invoke(o, ...);
  \end{javacodelinum}
}

Σε αυτές τις περιπτώσεις, μία στατική ανάλυση αδυνατεί να προβλέψει με
ακρίβεια τη μορφή των αντικειμένων που θα δημιουργηθούν και τις μεθόδους
που θα κληθούν δυναμικά, καθώς αυτό θα χρειαζόταν γνώση των τιμών των
συμβολοσειρών (π.χ., της {\en \code{className}}) που χρησιμοποιούνται
για την ανάκτηση κλάσεων, πεδίων, ή και μεθόδων.

Παρουσιάζονται τεχνικές που εστιάζουν στη μερική ανάλυση των
συμβολοσειρών που χρησιμοποιούνται για αυτό το σκοπό, καθώς και πιο
ισχυρές τεχνικές (όμοιες με αυτές για {\en C/C++}) που επιτυγχάνουν
δυναμική συσχέτιση αντικειμένων με υπάρχοντες τύπους.
%
Επίσης, γίνεται μία σύγκριση της πραγματικής δυναμικής συμπεριφοράς
των προγραμμάτων αναφοράς {\en DaCapo 9.12-Bach}, με το αποτέλεσμα
στατικής ανάλυσης που χρησιμοποιεί τις τεχνικές που παρουσιάζουμε. Η
σύγκριση μεταξύ του δυναμικού και των στατικών γράφων κλήσεων
αποτυπώνει τη βελτίωση στην ορθότητα της στατικής ανάλυσης που
επιφέρουν οι τεχνικές μας.


% ------------------------------------------------------------------------------
% Hierarchy and Program Complementation part
% ------------------------------------------------------------------------------

Το τέταρτο κεφάλαιο μελετά το πρόβλημα της συμπλήρωσης ιεραρχίας
κλάσεων. Η συμπλήρωση ιεραρχίας προκύπτει κατά το γενικότερο πρόβλημα
συμπλήρωσης μερικών προγραμμάτων {\en Java}, το οποίο προτείνουμε ως
μία γενική λύση στην ανάγκη ανάλυσης μερικών προγραμμάτων. Η ανάγκη
αυτή προκύπτει από τη δυνατότητα που προσφέρει η {\en Java} για
εκτέλεση μερικών προγραμμάτων (μέσω της δυναμικής φόρτωσης κλάσεων),
εφόσον τα μέρη του προγράμματος που λείπουν δεν είναι αναγκαία κατά
την εκτέλεση. Η δυνατότητα αυτή έχει δημιουργήσει τη τάση ευρείας
χρήσης βιβλιοθηκών που συχνά καθιστούν μη πρακτική, αν όχι ανέφικτη,
την ανάλυση του πλήρους προγράμματος. Κατά μία έννοια, η συμπλήρωση
μερικού προγράμματους ισοδυναμεί με την ανάκτηση της χαμένης δομικής
πληροφορίας για τους τύπους που απουσιάζουν και ανακατασκευάζονται ως
μέρος του ((συμπληρώματος)).

Η συμπλήρωση ιεραρχίας αφορά την ικανοποίηση ενός συγκεκριμένου
υποσυνόλου περιορισμών που προκύπτουν κατά τη συμπλήρωση προγράμματος:
των περιορισμών υποτυπισμού (του τύπου, η κλάση \(A\) πρέπει να είναι
υποτύπος της κλάσης \(B\)). Το πρόβλημα της συμπλήρωσης ιεραρχίας
εξετάζεται σε περιβάλλοντα μονής, πολλαπλής, και μεικτής
κληρονομικότητας. Σε κάθε περίπτωση, προσφέρουμε μία γραφοθεωρητική
μοντελοποίηση του προβλήματος, καθώς και αλγόριθμο που το επιλύει.

{\en
\begin{figure}[th]
  \renewcommand\figurename{{\gr Σχήμα}}
  \begin{minipage}[b]{.5\linewidth}
    \centering
    \includegraphics[scale=0.6]{figures/complementation/cgraph3.pdf}
    \subcaption[]{{\gr Γράφος περιορισμών}}\label{synopsis/fig:real-example:problem}
  \end{minipage}
  \begin{minipage}[b]{.5\linewidth}
    \centering
    \includegraphics[scale=0.6]{figures/complementation/cgraph3-solution.pdf}
    \subcaption[]{{\gr Λύση (πλήρης ιεραρχία)}}\label{synopsis/fig:real-example:solution}
  \end{minipage}
  \caption[]{{\gr Παράδειγμα ενός γράφου περιορισμών ιεραρχίας τύπων
      για την πλήρη {\en Java}. Οι διπλοί κύκλοι αντιστιχούν σε
      υπάρχοντες τύπους ({\en classes/interfaces}), των οποίων οι
      εξερχόμενες ακμές στη λύση είναι προκαθορισμένες και
      αναπαρίστανται ως κανονικές ακμές στον αρχικό γράφο. Οι
      διακεκομμένες ακμές εκφράζουν τους υπάρχοντες περιορισμούς
      υποτυπισμού. Οι λευκοί κόμβοι αναπαριστούν κλάσεις, οι μαύροι
      κόμβοι αναπαριστούν {\en intefaces}, και οι γκρίζοι κόμβοι
      αναπαριστούν τύπους οι οποίοι αρχικά είναι αγνώστου είδους.}}
  \label{synopsis/fig:real-example}
\end{figure}}

Το Σχήμα~\ref{synopsis/fig:real-example} παρουσιάζει ένα παράδειγμα
του προβλήματος για μεικτή κληρονομικότητα. Στα αριστερά έχουμε την
είσοδο του προβλήματος που περιλαμβάνει την υπάρχουσα μερική ιεραρχία
καθώς και τους περιορισμούς υποτυπισμού ως διακεκομμένες ακμές. Στα
δεξιά έχουμε μία πιθανή λύση του προβλήματος: μία πλήρη ιεραρχία, η
οποία ικανοποιεί όλους τους περιορισμούς υποτυπισμού στα αριστερά
(δηλαδή για κάθε διακεκομμένη ακμή στα αριστερά, υπάρχει ένα
αντίστοιχο μονοπάτι στην πλήρη ιεραρχία που παρουσιάζεται δεξιά).
Αυτοί οι περιορισμοί θα πρέπει να ικανοποιηθούν δίχως να αλλάξουν οι
εξερχόμενες ακμές των διαθέσιμων τύπων (αφού αυτοί αντιστοιχούν σε
κώδικα που ήδη διαθέτουμε). Παρουσιάζουμε αρκετά παραδείγματα που
δείχνουν πως η συμπλήρωση ιεραρχίας κλάσεων είναι σαφώς το δυσκολότερο
βήμα στο γενικότερο πρόβλημα της συμπλήρωσης μερικών προγραμμάτων.

Για την αξιολόγηση των τεχνικών μας, υλοποιήσαμε το εργαλείο {\en
  JPhantom}, για συμπλήρωση μερικών προγραμμάτων {\en Java}, το οποίο
παρέχει υλοποιήσεις όλων των αλγορίθμων συμπλήρωσης ιεραρχίας τύπων
που παρουσιάζουμε. Το {\en JPhantom} δέχεται ως είσοδο {\en Java
  bytecode}, στη μορφή ενός {\en JAR} αρχείου.
%
Τέλος, δείχνουμε αποτελέσματα της εφαρμογής του {\en JPhantom} σε
σύνθετα και ρεαλιστικά προγράμματα. Δείχνουμε επίσης πως η συμπλήρωση
μερικού προγράμματος (δηλαδή, η ανάκτηση της χαμένης δομικής
πληροφορίας για τους τύπους που απουσιάζουν) βελτιώνει τη στατική
ανάλυση του προγράμματος, όπως αυτή πραγματοποιείται από το εργαλείο
{\en \doop{}}, συγκρίνοντας με τα αποτελέσματα της ανάλυσης του
αρχικού (πλήρους) προγράμματος.


% ------------------------------------------------------------------------------
% Hierarchy and Program Complementation part
% ------------------------------------------------------------------------------

Στο πέμπτο κεφάλαιο διερευνούμε σχετική ερευνητική δουλειά, για τα
τρία βασικά μέρη του συνόλου των τεχνικών που παρουσιάσαμε. Έπειτα,
αναφέρουμε πηγές σχετικές με τον ευρύτερο τομέα της στατικής ανάλυσης
προγραμμάτων και παρουσιάζουμε διαφορετικές μεθοδολογίες με ιδιαίτερο
ενδιαφέρον.
%
Στο έκτο και τελευταίο κεφάλαιο παρουσιάζονται μελλοντικές ερευνητικές
κατευθύνσεις και τελική εκτίμηση της διατριβής.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
