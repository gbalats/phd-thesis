%%% Abstract in Greek

Η στατική ανάλυση στοχεύει στην κατανόηση της συμπεριφοράς του
προγράμματος, μέσω αυτοματοποιημένων τεχνικών συμπερασμού βασιζόμενες
καθαρά στον πηγαίο κώδικα του προγράμματος, αλλά δίχως να προϋποθέτουν
την εκτέλεση του κώδικα αυτού. Για να πετύχουν αυτές οι τεχνικές μία
ευρεία κατανόηση του κώδικα, καταφεύγουν στη δημιουργία ενός
αφηρημένου μοντέλου της μνήμης, το οποίο καλύπτει όλες τις πιθανές
εκτελέσεις. Αφηρημένα μοντέλα τέτοιου τύπου μπορεί γρήγορα να
εκφυλιστούν, αν χάσουν σημαντική δομική πληροφορία των αντικειμένων
στη μνήμη που περιγράφουν. Αυτό συνήθως συμβαίνει λόγω χρήσης
συγκεκριμένων προγραμματιστικών ιδιωμάτων και χαρακτηριστικών της
γλώσσας προγραμματισμού, ή λόγω πρακτικών περιορισμών της ανάλυσης.
Σε αρκετές περιπτώσεις, ένα σημαντικό μέρος της χαμένης αυτής δομικής
πληροφορίας μπορεί να ανακτηθεί μέσω σύνθετης λογικής η οποία
παρακολουθεί την έμμεση χρήση τύπων και να χρησιμοποιηθεί προς όφελος
της στατικής ανάλυσης του προγράμματος αυτού.

Στη διατριβή αυτή παρουσιάζουμε διάφορους τρόπους ανάκτησης δομικής
πληροφορίας, πρώτα
\begin{inparaenum}[(1)]
\item σε προγράμματα {\en C/C++}, κι έπειτα, σε προγράμματα γλωσσών
  υψηλότερου επιπέδου που δεν προσφέρουν άμεση πρόσβαση μνήμης, όπως η
  {\en Java}, όπου αναγνωρίζουμε δύο βασικές πηγές απώλειας δομικής
  πληροφορίας:
\item χρήση ανάκλασης και
\item ανάλυση μερικών προγραμμάτων.
\end{inparaenum}
Δείχνουμε πως, σε όλες τις παραπάνω περιπτώσεις, η ανάκτηση τέτοιας
δομικής πληροφορίας βελτιώνει άμεσα τη στατική ανάλυση του
προγράμματος.

Παρουσιάζουμε μία ανάλυση δεικτών για {\en C/C++}, η οποία βελτιώνει
το επίπεδο της αφαίρεσης, βασιζόμενη σε πληροφορία τύπου που
ανακαλύπτει κατά τη διάρκεια της ανάλυσης. Παρέχουμε μία υλοποίηση της
ανάλυσης αυτής, στο {\en \cclyzer{}}, ένα εργαλείο στατικής ανάλυσης
για {\en LLVM bitcode}.
%
Έπειτα, παρουσιάζουμε επεκτάσεις σε ανάλυση δεικτών για {\en Java},
κτίζοντας πάνω σε σύγχρονες τεχνικές χειρισμού μηχανισμών ανάκλασης. Η
βασική αρχή είναι παραπλήσια με την περίπτωση της {\en C/C++}:
καταγράφουμε τη χρήση των ανακλαστικών αντικειμένων, κατά τη διάρκεια
της ανάλυσης δεικτών, ώστε να ανακαλύψουμε βασικά δομικά τους
στοιχεία, τα οποία μπορούμε να χρησιμοποιήσουμε έπειτα για να
βελτιώσουμε τον χειρισμό των εντολών ανάκλασης στην τρέχουσα ανάλυση,
με αμοιβαία αναδρομικό τρόπο.
%
Τέλος, ως προς την ανάλυση μερικών προγραμμάτων {\en Java}, ορίζουμε
το γενικό πρόβλημα της ((\emph{συμπλήρωσης προγράμματος})): δοθέντος
ενός μερικού προγράμματος, πως να εφεύρουμε ένα υποκατάστατο του
κώδικα που λείπει, έτσι ώστε αυτό να ικανοποιεί τους περιορισμούς των
στατικών και δυναμικών τύπων που υπονοούνται από τον υπάρχοντα
κώδικα. Ή διαφορετικά, πως να ανακτήσουμε τη δομή των τύπων που
λείπουν. Πέρα της ανακάλυψης των μελών (πεδίων και μεθόδων) των
κλάσεων που λείπουν, η ικανοποίηση των περιορισμών υποτυπισμού μας
οδηγεί στον ορισμό ενός πρωτότυπου προβλήματος τύπων στον
αντικειμενοστρεφή κόσμο: η συμπλήρωση ιεραρχίας τύπων. Παρέχουμε
αλγορίθμους που λύσουν το πρόβλημα αυτό σε διάφορα είδη
κληρονομικότητας (μονής, πολλαπλής, μεικτής) και τους υλοποιούμε στο
{\en JPhantom}, ένα νέο εργαλείο συμπλήρωσης {\en Java bytecode}
κώδικα.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
