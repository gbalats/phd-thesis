%%% Abstract in Greek

Η στατική ανάλυση στοχεύει στη κατανόηση της συμπεριφοράς του
προγράμματος, μέσω αυτοματοποιημένων τεχνικών συμπερασμού βασιζόμενες
καθαρά στον πηγαίο κώδικα του προγράμματος, αλλά δίχως να προϋποθέτουν
την εκτέλεση του κώδικα αυτού. Για να πετύχουν αυτές οι τεχνικές μία
ευρεία κατανόηση του κώδικα, καταφεύγουν στη δημιουργία ενός
αφηρημένου μοντέλου της μνήμης, το οποίο καλύπτει όλες τις πιθανές
εκτελέσεις. Αφηρημένα μοντέλα τέτοιου τύπου μπορεί γρήγορα να
εκφυλιστούν, αν χάσουν σημαντική δομική πληροφορία των αντικειμένων
στη μνήμη που περιγράφουν. Αυτό συνήθως συμβαίνει λόγω χρήσης
συγκεκριμένων προγραμματιστικών ιδιωμάτων και χαρακτηριστικών της
γλώσσας προγραμματισμού, ή λόγω πρακτικών περιορισμών της ανάλυσης.
Σε αρκετές περιπτώσεις, ένα σημαντικό μέρος της χαμένης αυτής δομικής
πληροφορίας μπορεί να ανακτηθεί, μέσω σύνθετης λογικής η οποία
παρακολουθεί την έμμεση χρήση τύπων, και να χρησιμοποιηθεί προς όφελος
της στατικής ανάλυσης του προγράμματος αυτού.

Στη διατριβή αυτή παρουσιάζουμε τρόπους ανάκτησης δομικής πληροφορίας,
πρώτα
\begin{inparaenum}[(i)]
\item σε προγράμματα {\en C/C++}, κι έπειτα, σε προγράμματα γλωσσών
  υψηλότερου επιπέδου που δεν προσφέρουν άμεση πρόσβαση μνήμης, όπως η
  {\en Java}, όπου αναγνωρίζουμε δύο βασικές πηγές απώλειας δομικής
  πληροφορίας:
\item χρήση ανάκλασης και
\item ανάλυση μερικών προγραμμάτων.
\end{inparaenum}
Δείχνουμε πως, σε όλες τις παραπάνω περιπτώσεις, η ανάκτηση τέτοιας
δομικής πληροφορίας άμεσα βελτιώνει τη στατική ανάλυση του
προγράμματος.

Παρουσιάζουμε μία ανάλυση δεικτών για {\en C/C++}, η οποία βελτιώνει
το επίπεδο της αφαίρεσης, βασιζόμενη σε πληροφορία τύπου που
ανακαλύπτει κατά τη διάρκεια της ανάλυσης. Παρέχουμε μία υλοποίηση της
ανάλυσης αυτής, σε ένα εργαλείο στατικής ανάλησης για {\en LLVM
  bitcode}, ονόματι {\en \cclyzer{}}.
%
Έπειτα, παρουσιάζουμε επεκτάσεις σε ανάλυση δεικτών για {\en Java},
κτίζοντας πάνω σε τεχνικές αιχμής χειρισμού της ανάκλασης. 

% Next, we present techniques that extend a standard Java pointer
% analysis by building on top of state-of-the-art handling of
% reflection. The principle is similar to that of our
% structure-sensitive analysis for C/C++: track the use of reflective
% objects, \emph{during} pointer analysis, to gain important insights on
% their structure, which can be used to ``patch'' the handling of
% reflective operations on the running analysis, in a mutually recursive
% fashion.
% %
% Finally, to address the challenge of analyzing partial Java programs
% in full generality, we define the problem of ``program
% complementation'': given a partial program we seek to provide
% definitions for its missing parts so that the ``complement'' satisfies
% all static and dynamic typing requirements induced by the code under
% analysis. Essentially, complementation aims to recover the structure
% of phantom types.  Apart from discovering missing class members (i.e.,
% fields and methods), satisfying the subtyping constraints leads to the
% formulation of a novel typing problem in the OO context, regarding
% type hierarchy complementation. We offer algorithms to solve this
% problem in various inheritance settings, and implement them in
% JPhantom, a practical tool for Java bytecode complementation.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
